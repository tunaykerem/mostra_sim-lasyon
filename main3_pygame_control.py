#!/usr/bin/env python3
"""
Geli≈ümi≈ü WASD Manuel Kontrol Sistemi - Pygame ile
"""

import cv2
from setup import setup
from webcam1 import TrafficSignDetector
from Util import Global
from Controller import speed_controller
from Controller import lateral_controller as lc
from Util import Referans, State
import sys
import glob
import detection.detect as dt1
import detection.cone_detector as cd
import detection.torch_detector as torch_det
import math
try:
    sys.path.append(glob.glob('../../carla/dist/carla-0.9.15-py3.10-linux-x86_64.egg')[0])
except IndexError:
    pass
import carla
import threading
import time
import numpy as np
import pygame  # Pygame kullanƒ±mƒ±

from FinalPathGenerator import Levha
from FinalPathGenerator import setLabel
from FinalPathGenerator import PathGenerator as pg
from FinalPathGenerator import Main
from Util import Global
from Controller.waypoint_interpolation import WaypointInterpolation

# Pygame ba≈ülatma (klavye kontrol√º i√ßin)
pygame.init()
pygame.display.set_caption("CARLA Kontrol")
pygame.display.set_mode((100, 100), pygame.HIDDEN)  # Gizli pencere, sadece klavye giri≈üi i√ßin

# Ara√ß ve kamera
vehicle, camera, camera_data = setup()
s_c = speed_controller.DrivingController()

# Kontrol parametreleri
INTERP_LOOKAHEAD_DISTANCE = 1
INTERP_DISTANCE_RES = 0.01
closest_index = 0
closest_distance = 0
stop_event = threading.Event()
control_start_event = threading.Event()
trajectory_update_event = threading.Event()
trajectory_lock = threading.Lock()
keyboard_lock = threading.Lock()

# Dur i≈üareti deƒüi≈ükenleri
stop_sign_active = False
stop_sign_start_time = 0
STOP_DURATION = 3.0

# Manuel kontrol deƒüi≈ükenleri
manual_control = True  # Ba≈ülangƒ±√ßta manuel mod aktif
current_throttle = 0.0
current_steer = 0.0
current_brake = 0.0

# Y√∂r√ºnge ba≈ülatma
Global.x_main, Global.y_main = Main.getFinalTrajectory()
Global.stop_points = [[Global.x_main[-1], Global.y_main[-1]]]
Global.control_thread = True

def set_turn_signal(vehicle, left_signal=False, right_signal=False):
    """D√∂n√º≈ü sinyallerini ayarla"""
    try:
        current_lights = vehicle.get_light_state()
        
        if left_signal:
            current_lights |= carla.VehicleLightState.LeftBlinker
        else:
            current_lights &= ~carla.VehicleLightState.LeftBlinker
            
        if right_signal:
            current_lights |= carla.VehicleLightState.RightBlinker
        else:
            current_lights &= ~carla.VehicleLightState.RightBlinker

        vehicle.set_light_state(carla.VehicleLightState(current_lights))
    except Exception as e:
        print(f"Sinyal hatasƒ±: {e}")

def stop_threads():
    """T√ºm thread'leri durdur"""
    stop_event.set()
    pygame.quit()

def keyboard_control_thread():
    """Klavye kontrol√º i√ßin thread"""
    global manual_control, current_throttle, current_steer, current_brake
    
    print("üéÆ Klavye kontrol thread'i ba≈üladƒ±!")
    print("üéÆ Kontroller:")
    print("   W - ƒ∞leri (gaz)")
    print("   S - Geri (fren/geri)")
    print("   A - Sola d√∂n")
    print("   D - Saƒüa d√∂n")
    print("   SPACE - Acil fren")
    print("   M - Manuel/Otomatik mod deƒüi≈ütir")
    print("   Q - √áƒ±kƒ±≈ü")
    
    clock = pygame.time.Clock()
    
    while not stop_event.is_set():
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                stop_threads()
                break
                
            # Manuel/Otomatik mod deƒüi≈ütirme
            if event.type == pygame.KEYDOWN and event.key == pygame.K_m:
                with keyboard_lock:
                    manual_control = not manual_control
                    current_throttle = 0.0
                    current_steer = 0.0
                    current_brake = 0.0
                print(f"{'üéÆ MANUEL' if manual_control else 'ü§ñ OTOMATƒ∞K'} mod aktif!")
                
            # √áƒ±kƒ±≈ü tu≈üu
            if event.type == pygame.KEYDOWN and event.key == pygame.K_q:
                print("üõë √áƒ±kƒ±≈ü tu≈üuna basƒ±ldƒ±, program kapatƒ±lƒ±yor...")
                stop_threads()
                break
        
        # Manuel modda WASD kontrolleri
        if manual_control:
            keys = pygame.key.get_pressed()
            
            with keyboard_lock:
                # Gaz/Fren kontrol√º (W/S)
                if keys[pygame.K_w]:
                    current_throttle = min(1.0, current_throttle + 0.05)
                    current_brake = 0.0
                    print(f"üöó ƒ∞leri: {current_throttle:.2f}")
                elif keys[pygame.K_s]:
                    # Hƒ±za g√∂re fren veya geri vites
                    velocity = vehicle.get_velocity()
                    speed = (velocity.x**2 + velocity.y**2 + velocity.z**2)**0.5
                    if speed > 0.5:  # ƒ∞leri gidiyorsa, √∂nce fren
                        current_brake = min(1.0, current_brake + 0.1)
                        current_throttle = 0.0
                        print(f"üõë Fren: {current_brake:.2f}")
                    else:  # Durmu≈üsa, geri vites
                        current_throttle = -0.5
                        current_brake = 0.0
                        print("üîÑ Geri")
                else:
                    # Tu≈ü basƒ±lƒ± deƒüilse yava≈ü√ßa azalt
                    current_throttle = max(0.0, current_throttle - 0.03)
                    current_brake = max(0.0, current_brake - 0.1)
                
                # Direksiyon kontrol√º (A/D)
                if keys[pygame.K_a]:
                    current_steer = max(-0.9, current_steer - 0.05)
                    print(f"‚¨ÖÔ∏è Sola: {current_steer:.2f}")
                elif keys[pygame.K_d]:
                    current_steer = min(0.9, current_steer + 0.05)
                    print(f"‚û°Ô∏è Saƒüa: {current_steer:.2f}")
                else:
                    # Merkeze doƒüru yava≈ü√ßa d√ºzelt
                    if current_steer > 0:
                        current_steer = max(0.0, current_steer - 0.05)
                    else:
                        current_steer = min(0.0, current_steer + 0.05)
                
                # Acil fren - Space tu≈üu
                if keys[pygame.K_SPACE]:
                    current_brake = 1.0
                    current_throttle = 0.0
                    print("üõë ACƒ∞L FREN!")
            
            # Kontrol deƒüerlerini ekrana yaz
            print(f"üéÆ KONTROL: Gaz={current_throttle:.2f}, D√∂n√º≈ü={current_steer:.2f}, Fren={current_brake:.2f}")
        
        clock.tick(20)  # 20 FPS - CPU kullanƒ±mƒ±nƒ± azaltmak i√ßin

def detection_thread():
    """Nesne tespiti ve yol trafik i≈üaretlerini algƒ±layan thread"""
    global stop_sign_active, stop_sign_start_time
    
    print("üîç Tespit thread'i ba≈üladƒ±!")
    detector = torch_det.SimpleYOLOv8Detector('last.pt')
    cone_detector = cd.ConeDetector()
    
    # Koni engelleri i√ßin
    import detection.cone_avoidance as ca
    cone_avoidance = ca.ConeAvoidanceSystem()
    
    while not stop_event.is_set():
        try:
            # Kamera g√∂r√ºnt√ºs√ºn√º al
            frame = camera_data['image'][:, :, :-1]
            frame = frame.astype(np.uint8)
            
            # YOLOv8 ile i≈üareteri tespit et
            start_time = time.time()
            result = detector.process_frame(frame)
            
            if isinstance(result, tuple) and len(result) >= 2:
                frame, levha = result[0], result[1]
                
                print(f"üîç YOLOv8 Tespiti: '{levha}'")
                
                # Dur i≈üareti algƒ±lama (durak deƒüil)
                is_dur = False
                if levha and levha != "None":
                    levha_clean = str(levha).strip().lower()
                    
                    if levha_clean == "dur":
                        is_dur = True
                        print(f"‚úÖ TAM DUR E≈ûLE≈ûMESƒ∞: '{levha}'")
                    elif "durak" in levha_clean:
                        print(f"üöå DURAK tespit edildi (yok sayƒ±lƒ±yor): '{levha}'")
                    elif "dur" in levha_clean and "durak" not in levha_clean:
                        is_dur = True
                        print(f"‚ö†Ô∏è KISMƒ∞ DUR E≈ûLE≈ûMESƒ∞: '{levha}'")
                
                # Manuel modda deƒüilse dur i≈üareti uygulamasƒ±
                with keyboard_lock:
                    is_manual = manual_control
                
                if is_dur and not is_manual:
                    if not stop_sign_active:
                        print("üõëüõëüõë DUR ƒ∞≈ûARETƒ∞ TESPƒ∞T EDƒ∞LDƒ∞! 3 saniye bekleniyor...")
                        stop_sign_active = True
                        stop_sign_start_time = time.time()
                        Global.breaking = 1.0
                
                # Dur i≈üareti s√ºresini kontrol et
                if stop_sign_active and not is_manual:
                    elapsed = time.time() - stop_sign_start_time
                    if elapsed >= STOP_DURATION:
                        print("‚úÖ Bekleme s√ºresi tamamlandƒ±! Devam ediliyor...")
                        stop_sign_active = False
                        Global.breaking = 0.0
                    else:
                        remaining = STOP_DURATION - elapsed
                        print(f"‚è±Ô∏è DUR AKTƒ∞F: {remaining:.1f}s kaldƒ±")
                        Global.breaking = 1.0
            else:
                levha = "None"
                if result is not None:
                    frame = result
            
            # Koni tespiti (YOLO tarafƒ±ndan zaten koni tespit edilmemi≈üse)
            yolo_detected_cone = (levha.lower() in ["koni", "cone"]) if levha != "None" else False
            
            cone_positions = []
            if not yolo_detected_cone:
                # Geleneksel koni dedekt√∂r√ºn√º kullan
                cone_positions, frame = cone_detector.detect_cones(frame)
                
                # Koni pozisyonlarƒ±nƒ± engelden ka√ßƒ±nma sistemi ile i≈üle
                obstacle_changed, obstacle_data = cone_avoidance.process_cone_detections(cone_positions)
            else:
                # YOLO koni tespit ettiyse, engelden ka√ßƒ±nma i√ßin i≈üle
                cone_positions = [[0, 3.0]]  # Koni 3m ileride, merkezde
                obstacle_changed, obstacle_data = cone_avoidance.process_cone_detections(cone_positions)
                print(f"üî¥ YOLO koni tespit etti: {levha}")
            
            # Manuel modda deƒüilse, engel durumu deƒüi≈ütiyse y√∂r√ºngeyi g√ºncelle
            with keyboard_lock:
                is_manual = manual_control
            
            if obstacle_changed and not is_manual:
                print(f"üö® Engel durumu deƒüi≈üti ({len(cone_positions)} koni), y√∂r√ºnge yeniden olu≈üturuluyor...")
                
                if Global.dubaVar:
                    try:
                        # Engelden ka√ßƒ±nma y√∂r√ºngesi olu≈ütur
                        current_x = Global.current_x
                        current_y = Global.current_y
                        direction = Global.direction
                        
                        x_avoid, y_avoid = cone_avoidance.generate_avoidance_path(
                            current_x, current_y, direction)
                        
                        if x_avoid and y_avoid and len(x_avoid) > 0:
                            with trajectory_lock:
                                Global.x_main, Global.y_main = x_avoid, y_avoid
                                Global.avoidance_active = True
                            
                            trajectory_update_event.set()
                            print(f"‚úÖ Yeni ka√ßƒ±≈ü y√∂r√ºngesi olu≈üturuldu ({len(Global.x_main)} nokta)")
                        else:
                            print("‚ùå Ge√ßerli ka√ßƒ±≈ü y√∂r√ºngesi bulunamadƒ± - ACƒ∞L DURUM YEDEK PLANI")
                            # Basit acil durum ka√ßƒ±≈ü planƒ±
                            lateral_offset = 3.0
                            x_points = []
                            y_points = []
                            
                            if direction == "K":  # Kuzey
                                x_points = [current_x, current_x - lateral_offset, current_x - lateral_offset, current_x]
                                y_points = [current_y, current_y + 2, current_y + 10, current_y + 15]
                            elif direction == "G":  # G√ºney
                                x_points = [current_x, current_x + lateral_offset, current_x + lateral_offset, current_x]
                                y_points = [current_y, current_y - 2, current_y - 10, current_y - 15]
                            elif direction == "D":  # Doƒüu
                                x_points = [current_x, current_x + 2, current_x + 10, current_x + 15]
                                y_points = [current_y, current_y + lateral_offset, current_y + lateral_offset, current_y]
                            elif direction == "B":  # Batƒ±
                                x_points = [current_x, current_x - 2, current_x - 10, current_x - 15]
                                y_points = [current_y, current_y - lateral_offset, current_y - lateral_offset, current_y]
                            
                            with trajectory_lock:
                                Global.x_main, Global.y_main = x_points, y_points
                                Global.avoidance_active = True
                            
                            trajectory_update_event.set()
                            print(f"üÜò ACƒ∞L DURUM ka√ßƒ±≈ü yolu olu≈üturuldu ({len(x_points)} nokta)")
                    except Exception as e:
                        print(f"‚ùå Y√∂r√ºnge yeniden olu≈üturma hatasƒ±: {e}")
                        
                        # Son √ßare olarak orijinal y√∂r√ºngeyi kullan
                        with trajectory_lock:
                            if not Global.x_main or len(Global.x_main) == 0:
                                try:
                                    Global.x_main, Global.y_main = Main.getFinalTrajectory()
                                    print(f"‚ö†Ô∏è Orijinal y√∂r√ºngeye d√∂n√ºl√ºyor ({len(Global.x_main)} nokta)")
                                except Exception as e2:
                                    print(f"üí• KRƒ∞Tƒ∞K: Final y√∂r√ºnge alƒ±namadƒ±: {e2}")
                        
                        trajectory_update_event.set()
                else:
                    # Engel yok, ama daha √∂nce ka√ßƒ±nma modundaydƒ±k, normal y√∂r√ºngeye d√∂n
                    if getattr(Global, 'avoidance_active', False):
                        try:
                            with trajectory_lock:
                                Global.x_main, Global.y_main = Main.getFinalTrajectory()
                                Global.avoidance_active = False
                            
                            trajectory_update_event.set()
                            print(f"‚úÖ Normal y√∂r√ºngeye d√∂n√ºld√º ({len(Global.x_main)} nokta)")
                        except Exception as e:
                            print(f"‚ùå Normal y√∂r√ºngeye d√∂n√º≈ü hatasƒ±: {e}")
            
            # FPS ve zaman bilgisi
            elapsed_time = time.time() - start_time
            fps = 1.0 / elapsed_time if elapsed_time > 0 else 0
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            
            # Ekrana bilgileri ekle
            cv2.putText(frame, f"FPS: {fps:.1f}", (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)
            cv2.putText(frame, f"Tespit: {levha}", (20, 100), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)
            cv2.putText(frame, f"Poz: ({Global.current_x:.1f}, {Global.current_y:.1f}) Y√∂n: {Global.direction}", 
                       (20, 150), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 0, 0), 2)
            
            # Kontrol modu g√∂stergesi
            with keyboard_lock:
                mode_text = "MANUEL KONTROL (WASD)" if manual_control else "OTOMATƒ∞K KONTROL"
                mode_color = (0, 0, 255) if manual_control else (0, 255, 0)
            
            cv2.rectangle(frame, (10, 180), (600, 230), mode_color, -1)
            cv2.putText(frame, mode_text, (20, 215), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 2)
            
            # Manuel modda kontrol deƒüerlerini g√∂ster
            with keyboard_lock:
                is_manual = manual_control
                t_val = current_throttle
                s_val = current_steer
                b_val = current_brake
            
            if is_manual:
                control_text = f"Gaz: {t_val:.2f} | Direksiyon: {s_val:.2f} | Fren: {b_val:.2f}"
                cv2.putText(frame, control_text, (20, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
                cv2.putText(frame, "M tu≈üu ile otomatik moda ge√ß", (20, 300), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
            else:
                # Otomatik modda dur i≈üareti g√∂stergesi
                if stop_sign_active:
                    elapsed_time = time.time() - stop_sign_start_time
                    remaining_time = STOP_DURATION - elapsed_time
                    if remaining_time > 0:
                        cv2.rectangle(frame, (10, 240), (800, 300), (0, 0, 255), -1)
                        cv2.rectangle(frame, (10, 240), (800, 300), (255, 255, 255), 3)
                        cv2.putText(frame, f"üõë DUR LEVHASƒ∞ AKTƒ∞F - BEKLEME: {remaining_time:.1f}s", 
                                  (20, 280), cv2.FONT_HERSHEY_SIMPLEX, 1.2, (255, 255, 255), 3)
                        
                        cv2.putText(frame, f"Tespit edilen: {levha}", 
                                  (20, 320), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 0), 2)
                else:
                    cv2.putText(frame, "M tu≈üu ile manuel moda ge√ß", (20, 260), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
            
            # Koni tespit bilgisi
            base_y_pos = 320 if is_manual else 360
            if len(cone_positions) > 0:
                closest_cone = min(cone_positions, key=lambda pos: math.sqrt(pos[0]**2 + pos[1]**2))
                cv2.putText(frame, f"KONƒ∞ TESPƒ∞T EDƒ∞LDƒ∞: {closest_cone[1]:.1f}m ileride, {closest_cone[0]:.1f}m offset", 
                           (20, base_y_pos), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 255), 3)
                
                # Engelden ka√ßƒ±nma uyarƒ±sƒ±
                if Global.dubaVar and not is_manual:
                    warning_y_start = base_y_pos + 20
                    warning_y_end = warning_y_start + 50
                    cv2.rectangle(frame, (10, warning_y_start), (600, warning_y_end), (0, 0, 255), -1)
                    cv2.putText(frame, "‚ö†Ô∏è ENGELDEN KA√áINMA AKTƒ∞F ‚ö†Ô∏è", 
                               (20, warning_y_start + 30), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 2)
                    
                    # Engel detaylarƒ±
                    obstacle_details = f"Engel verisi: {Global.dubaEngel}"
                    cv2.putText(frame, obstacle_details, (20, warning_y_end + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                    
                    # Mevcut ka√ßƒ±nma yolu bilgisi
                    if hasattr(Global, 'avoidance_path') and Global.avoidance_path:
                        path_info = f"Ka√ßƒ±nma yolu: {len(Global.avoidance_path)} nokta"
                        cv2.putText(frame, path_info, (20, warning_y_end + 60), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
            
            # Timestamp
            timestamp_y = 500 if len(cone_positions) > 0 else 450
            cv2.putText(frame, timestamp, (20, timestamp_y), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 2)
            
            # √áƒ±kƒ±≈ü bilgisi
            cv2.putText(frame, "√áƒ±kƒ±≈ü i√ßin Q tu≈üuna basƒ±n", (20, timestamp_y + 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
            
            # G√∂r√ºnt√ºy√º g√∂ster
            cv2.imshow('CARLA Kamera - Q:√áƒ±kƒ±≈ü, M:Mod Deƒüi≈ütir, WASD:Kontrol', frame)
            
            # Otomatik modda i≈üaret bilgisiyle global durumu g√ºncelle
            if not is_manual and levha != "None":
                # √ñnceki y√∂r√ºngeyi sakla (kar≈üƒ±la≈ütƒ±rma i√ßin)
                with trajectory_lock:
                    prev_x = Global.x_main.copy() if hasattr(Global, 'x_main') and Global.x_main else []
                    prev_y = Global.y_main.copy() if hasattr(Global, 'y_main') and Global.y_main else []
                
                # Levha bilgisiyle g√ºncelle
                Levha.levha(levha, Global.direction, Global.current_x, Global.current_y)
                
                # Y√∂r√ºnge deƒüi≈ütiyse thread 2'yi uyar
                with trajectory_lock:
                    if (obstacle_changed or 
                        not prev_x or not prev_y or 
                        len(Global.x_main) != len(prev_x) or 
                        len(Global.y_main) != len(prev_y) or
                        not np.array_equal(Global.x_main, prev_x) or 
                        not np.array_equal(Global.y_main, prev_y)):
                        
                        print("Y√∂r√ºnge g√ºncellendi! Kontrol thread'i bilgilendiriliyor...")
                        trajectory_update_event.set()
            
            # Thread2'nin ba≈ülamasƒ± i√ßin i≈üaret ver
            if Global.control_thread:
                control_start_event.set()
                Global.control_thread = False
            
            # 'q' ile √ßƒ±kƒ±≈ü
            key = cv2.waitKey(1)
            if key == ord('q'):
                print("Q tu≈üuna basƒ±ldƒ±, ara√ß ve kamera siliniyor...")
                stop_threads()
                break
        
        except Exception as e:
            print(f"‚ùå Tespit thread'inde hata: {e}")
            time.sleep(0.1)

def control_thread():
    """Ara√ß kontrol thread'i"""
    print("üöó Kontrol thread'i ba≈üladƒ± - sinyal bekleniyor")
    
    # Dur i≈üareti deƒüi≈ükenleri
    global stop_sign_active, stop_sign_start_time
    
    control_start_event.wait()  # Sinyal gelene kadar bekle
    print("üöó Kontrol d√∂ng√ºs√º ba≈üladƒ±")
    
    # Waypoint'leri ba≈ülat
    with trajectory_lock:
        current_waypoints = np.array(list(zip(Global.x_main, Global.y_main)))
    
    print(f"ƒ∞lk kontrol noktalarƒ±: {len(current_waypoints)} nokta")
    if len(current_waypoints) > 0:
        print(f"ƒ∞lk nokta: {current_waypoints[0]}")
        if len(current_waypoints) > 1:
            print(f"Son nokta: {current_waypoints[-1]}")
    
    while not stop_event.is_set():
        # Manuel kontrol modunu kontrol et
        with keyboard_lock:
            is_manual = manual_control
            man_throttle = current_throttle
            man_steer = current_steer
            man_brake = current_brake
        
        # Manuel modda doƒürudan kullanƒ±cƒ± kontrollerini uygula
        if is_manual:
            control_command = carla.VehicleControl(
                throttle=man_throttle if man_throttle >= 0 else 0,
                steer=man_steer,
                brake=man_brake if man_throttle >= 0 else 0,
                reverse=True if man_throttle < 0 else False
            )
            vehicle.apply_control(control_command)
            
            # D√∂n√º≈ü sinyallerini direksiyon a√ßƒ±sƒ±na g√∂re ayarla
            if man_steer > 0.3:
                set_turn_signal(vehicle, left_signal=False, right_signal=True)
            elif man_steer < -0.3:
                set_turn_signal(vehicle, left_signal=True, right_signal=False)
            else:
                set_turn_signal(vehicle, left_signal=False, right_signal=False)
            
            # Manuel modda global konum bilgilerini g√ºncelle
            location = vehicle.get_location()
            Global.current_x = location.x
            Global.current_y = location.y
            transform = vehicle.get_transform()
            Global.yaw = transform.rotation.yaw
            
            # Ara√ß y√∂n√ºn√º g√ºncelle
            from Controller.yon import get_direction
            get_direction()
            
            time.sleep(0.02)
            continue
        
        # OTOMATƒ∞K KONTROL MODU a≈üaƒüƒ±da
        # Y√∂r√ºnge g√ºncellemelerini kontrol et
        if trajectory_update_event.is_set():
            print("üîÑ Y√∂r√ºnge g√ºncellemesi tespit edildi - kontrol noktalarƒ± g√ºncelleniyor...")
            with trajectory_lock:
                # x_main ve y_main ge√ßerli mi kontrol et
                if (hasattr(Global, 'x_main') and hasattr(Global, 'y_main') and 
                    Global.x_main is not None and Global.y_main is not None and
                    len(Global.x_main) > 0 and len(Global.y_main) > 0):
                    
                    # Global y√∂r√ºngeden waypoint'leri HEMEN g√ºncelle
                    current_waypoints = np.array(list(zip(Global.x_main, Global.y_main)))
                    print(f"‚úÖ Waypoint'ler g√ºncellendi: {len(current_waypoints)} nokta")
                    
                    # Yeni y√∂r√ºngenin ilk ve son noktalarƒ±nƒ± yazdƒ±r
                    if len(current_waypoints) > 0:
                        print(f"ƒ∞lk nokta: {current_waypoints[0]}")
                        if len(current_waypoints) > 1:
                            print(f"Son nokta: {current_waypoints[-1]}")
                    
                    # Ka√ßƒ±nma modunda mƒ±yƒ±z kontrol et
                    if getattr(Global, 'avoidance_active', False):
                        print("‚ö†Ô∏è KA√áINMA MODU AKTƒ∞F - ka√ßƒ±nma y√∂r√ºngesi takip ediliyor")
                else:
                    print("‚ùå Uyarƒ±: Global'de ge√ßersiz x_main veya y_main, √∂nceki waypoint'ler korunuyor")
            
            # ƒ∞≈ülendikten sonra event'i temizle
            trajectory_update_event.clear()
        
        # Ge√ßerli waypoint'lerimiz olduƒüundan emin ol
        if len(current_waypoints) == 0:
            print("Ge√ßerli waypoint yok, yeniden olu≈üturmaya √ßalƒ±≈üƒ±lƒ±yor")
            try:
                with trajectory_lock:
                    Global.x_main, Global.y_main = Main.getFinalTrajectory()
                    current_waypoints = np.array(list(zip(Global.x_main, Global.y_main)))
                print(f"Waypoint'ler yeniden olu≈üturuldu: {len(current_waypoints)} nokta")
            except Exception as e:
                print(f"‚ùå Waypoint yeniden olu≈üturma hatasƒ±: {e}")
                time.sleep(0.1)
                continue
        
        # Mevcut waypoint'leri kontrol i√ßin kullan
        try:
            wp_interp, wp_distance, wp_interp, wp_interp_hash = WaypointInterpolation.interpolate_waypoints(current_waypoints, INTERP_DISTANCE_RES)
        except Exception as e:
            print(f"‚ùå Waypoint interpolasyon hatasƒ±: {e}")
            time.sleep(0.1)
            continue
        
        location = vehicle.get_location()
        
        # Global konum deƒüi≈ükenlerini g√ºncelle
        Global.current_x = location.x
        Global.current_y = location.y
        
        velocity = vehicle.get_velocity()
        transform = vehicle.get_transform()
        Global.yaw = transform.rotation.yaw
        
        # Aracƒ±n y√∂n√ºn√º yaw'a g√∂re g√ºncelle
        from Controller.yon import get_direction
        get_direction()
        
        try:
            # Ara√ß kontrollerini al
            throttle = s_c.update(vehicle)
            steer = lc.update(vehicle, current_waypoints, wp_distance, wp_interp, wp_interp_hash, INTERP_LOOKAHEAD_DISTANCE, closest_index, closest_distance)
            
            # Dur i≈üareti kontrol mantƒ±ƒüƒ±
            if stop_sign_active:
                # ZORLA DURDUR - her ≈üeyi ge√ßersiz kƒ±l, Global.breaking kullan
                throttle = 0.0
                Global.breaking = 1.0
                print(f"üõë ZORLA DURDURMA: fren={Global.breaking}, gaz={throttle}")
            else:
                # Normal s√ºr√º≈ü - Global.breaking ayarƒ±na uy
                if Global.breaking > 0:
                    print(f"üöó Normal w/ fren: fren={Global.breaking}, gaz={throttle}")
                else:
                    print(f"üöó Normal s√ºr√º≈ü: fren={Global.breaking}, gaz={throttle}")
            
            # Ka√ßƒ±nma modunda g√ºvenlik i√ßin hƒ±zƒ± azalt
            if getattr(Global, 'avoidance_active', False):
                print(f"üê¢ Ka√ßƒ±nma i√ßin hƒ±z azaltƒ±ldƒ± (gaz: {throttle:.2f} -> {throttle * 0.7:.2f})")
                throttle *= 0.7
            
            # Ara√ß kontrollerini uygula
            control_command = carla.VehicleControl(throttle=throttle, steer=steer, brake=Global.breaking)
            vehicle.apply_control(control_command)
            
            # D√∂n√º≈ü sinyallerini direksiyon a√ßƒ±sƒ±na g√∂re ayarla
            if steer > 0.1:
                set_turn_signal(vehicle, left_signal=False, right_signal=True)
            elif steer < -0.1:
                set_turn_signal(vehicle, left_signal=True, right_signal=False)
            else:
                set_turn_signal(vehicle, left_signal=False, right_signal=False)
        except Exception as e:
            print(f"‚ùå Kontrol d√∂ng√ºs√ºnde hata: {e}")
            # G√ºvenli varsayƒ±lanlarƒ± uygula
            vehicle.apply_control(carla.VehicleControl(throttle=0.0, steer=0.0, brake=1.0))
            set_turn_signal(vehicle, left_signal=False, right_signal=False)

        State.set_state()
        Referans.set_referance()
        
        # Ka√ßƒ±nma modunda deƒüilse durma noktalarƒ±nƒ± yazdƒ±r
        if not getattr(Global, 'avoidance_active', False):
            print(Global.stop_points)

def main():
    """Ana program"""
    print("=================================================")
    print("CARLA WASD Kontrol + Otomatik S√ºr√º≈ü Sistemi")
    print("=================================================")
    print("Kontroller:")
    print("  M     - Manuel/Otomatik mod deƒüi≈ütir")
    print("  W     - ƒ∞leri (gaz)")
    print("  S     - Fren/Geri")
    print("  A     - Sola d√∂n")
    print("  D     - Saƒüa d√∂n")
    print("  SPACE - Acil fren")
    print("  Q     - √áƒ±kƒ±≈ü")
    print("=================================================")
    print("MANUEL modda ba≈ülƒ±yor. Otomatik moda ge√ßmek i√ßin M tu≈üuna basƒ±n.")
    print("=================================================")
    
    # Thread'leri olu≈ütur
    kb_thread = threading.Thread(target=keyboard_control_thread)
    detect_thread = threading.Thread(target=detection_thread)
    ctrl_thread = threading.Thread(target=control_thread)
    
    # Thread'leri ba≈ülat
    kb_thread.start()
    detect_thread.start()
    ctrl_thread.start()
    
    try:
        # Ana thread aktif tut
        while not stop_event.is_set():
            time.sleep(1)
            with keyboard_lock:
                mode_text = "MANUEL" if manual_control else "OTOMATƒ∞K"
            print(f"üöó {mode_text} MOD AKTIF - √áƒ±kƒ±≈ü i√ßin Q tu≈üuna basƒ±n")
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Klavye kesintisi, kapatƒ±lƒ±yor...")
        stop_threads()
    
    # Thread'lerin bitmesini bekle
    kb_thread.join()
    detect_thread.join()
    ctrl_thread.join()
    
    # Kaynaklarƒ± temizle
    print("Kaynaklar temizleniyor...")
    if 'camera' in globals() and camera.is_listening:
        camera.stop()
    if 'camera' in globals() and camera.is_alive:
        camera.destroy()
    if 'vehicle' in globals() and vehicle.is_alive:
        vehicle.destroy()
    cv2.destroyAllWindows()
    pygame.quit()
    print("Temizlik tamamlandƒ±.")

if __name__ == "__main__":
    main()
